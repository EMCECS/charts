// This is VDC-wide GC chunk-based data generation CQ
// Generates:
// "user_gc_pending", "user_gc_unreclaim"
// "system_gc_pending", "system_gc_unreclaim"
// Calculation is coming from ECS Dashboard API code

import "http"
chunk_size = 134217600

// RETRIEVE GC RAW DATA
gc_data = from(bucket: "monitoring_vdc")
    // select only required fields/measurements for further functions
    |> filter(fn: (r) => r._measurement =~ /^cq_total_(cm|sr)_(REPO|BTREE)_GC_Statistics$/
              and r._field =~ /^(deleted_chunks_repo|ec_freed_slots|slots_waiting_shipping|full_reclaimable_repo_chunk|full_reclaimable_aligned_chunk|total_repo_garbage|deleted_chunks_btree_level_(0|1)|verification_waiting_chunks_btree_gc_level_(0|1)|candidate_chunks_btree_gc_level_(0|1))$/)
    |> range(start:{{ .Start }}, stop:{{ .Stop }})
    // select only last value for given range
    |> last()
    // note/todo - how to filter out unnecessary tables like coming from actually removed hosts?
    |> keep(columns:["_stop", "_field", "_value"])
    |> group()

// USER GC
// transformed by pivot -> map -> reversal pivot
zx = gc_data
    |> filter(fn: (r) => r._field =~ /^(deleted_chunks_repo|ec_freed_slots|slots_waiting_shipping|full_reclaimable_repo_chunk|full_reclaimable_aligned_chunk|total_repo_garbage)$/)
    // pivot requires row key different from column and value keys. since there is no other columns initially, extra column is added
    |> set(key: "void", value: "1")
    |> pivot(rowKey:["void"],columnKey: ["_field"],valueColumn: "_value")
    |> map(fn: (r) => ({
            user_reclaimed:
                ((r.deleted_chunks_repo * chunk_size) + (r.ec_freed_slots * (chunk_size / 60))),
            user_pending:
                ((r.slots_waiting_shipping * chunk_size / 60)
                + (r.full_reclaimable_repo_chunk - r.full_reclaimable_aligned_chunk) * chunk_size),
            total_repo_garbage: r.total_repo_garbage,
                        }))
    |> map(fn: (r) => ({0_req_for_keyval:0,
                        user_gc_reclaimed: r.user_reclaimed
                        user_gc_pending: r.user_pending,
                        user_gc_unreclaim: r.total_repo_garbage - r.user_pending
                        }))
    // this is resersal pivot
    // 0_req_for_keyval is required due to bug? in keyValues - column id of find key should be > 0
    // |> keyValues(keyColumns:["user_gc_pending","user_gc_unreclaim","user_gc_reclaimed"])

//workaround for https://github.com/influxdata/flux/issues/2528
zx1 = zx |> keyValues(keyColumns:["user_gc_pending"])
zx2 = zx |> keyValues(keyColumns:["user_gc_unreclaim"])
zx3 = zx |> keyValues(keyColumns:["user_gc_reclaimed"])
gc_user = union(tables:[zx1,zx2,zx3])
    |> rename(columns:{_key: "_field"})

// SYSTEM GC
zy = gc_data
    |> filter(fn: (r) => r._field =~ /^(deleted_chunks_btree_level_(0|1)|verification_waiting_chunks_btree_gc_level_(0|1)|candidate_chunks_btree_gc_level_(0|1))$/)
    |> set(key: "void", value: "1")
    |> pivot(rowKey:["void"],columnKey: ["_field"],valueColumn: "_value")
    |> map(fn: (r) => ({
                        system_reclaimed:
                        (r.deleted_chunks_btree_level_0 + r.deleted_chunks_btree_level_1) * chunk_size,
                        system_pending:
                        (r.verification_waiting_chunks_btree_gc_level_0
                            + r.verification_waiting_chunks_btree_gc_level_1) * chunk_size,
                        system_unreclaim_full:
                        (r.candidate_chunks_btree_gc_level_0
                            + r.candidate_chunks_btree_gc_level_1) * chunk_size
                        }))
    |> map(fn: (r) => ({0_req_for_keyval:0,
                        system_gc_reclaimed: r.system_reclaimed,
                        system_gc_pending: r.system_pending,
                        system_gc_unreclaim: r.system_unreclaim_full - r.system_pending
                        }))
    // |> keyValues(keyColumns:["system_gc_pending","system_gc_unreclaim","system_gc_reclaimed"])

//workaround for https://github.com/influxdata/flux/issues/2528
zy1 = zy |> keyValues(keyColumns:["system_gc_pending"])
zy2 = zy |> keyValues(keyColumns:["system_gc_unreclaim"])
zy3 = zy |> keyValues(keyColumns:["system_gc_reclaimed"])
    // rename is used to unify output for further union() - as it expects _field = _value structure
gc_system = union(tables:[zy1,zy2,zy3])
    |> rename(columns:{_key: "_field"})

// PRODUCE FINAL OUTPUT
union(tables:[gc_user, gc_system])
    // insert _time field equal to .Stop from CQ engine
    |> map(fn: (r) => ({_time:{{ .Stop }},
                        _field: r._field,
                        _value: r._value,
                        }))
    |> pivot(rowKey:["_time"], columnKey: ["_field"], valueColumn: "_value")
    |> group()